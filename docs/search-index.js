var searchIndex = {};
searchIndex["bpf_bindings"] = {"doc":"Simple Bindings to BPF","items":[[3,"bpf_insn","bpf_bindings","Berkeley Packet Filter Instruction",null,null],[12,"code","","",0,null],[12,"jt","","",0,null],[12,"jf","","",0,null],[12,"k","","",0,null],[3,"bpf_program","","Berkeley Packet Filter Program",null,null],[12,"bf_len","","",1,null],[12,"bj_insns","","",1,null],[3,"bpf_factory","","Berkeley Packet Filter Program Factory",null,null],[3,"LoadA","","Load Accumulator Register",null,null],[3,"LoadX","","Load Index Register",null,null],[3,"StoreReg","","Store Register",null,null],[3,"Alu","","ALU Commands.",null,null],[3,"Jmp","","Jump Instructions",null,null],[3,"Ret","","Exit Program",null,null],[3,"CopyReg","","Copy Reg",null,null],[4,"SliceSize","","This enum is used to set the size of a read or write. Word reads 32bits, 4 bytes.\nHalfWord reads 16bits, 2 bytes. Byte sets... well 1 byte.",null,null],[13,"Word","","",2,null],[13,"HalfWord","","",2,null],[13,"Byte","","",2,null],[11,"hash","","",0,null],[11,"cmp","","",0,null],[11,"partial_cmp","","",0,null],[11,"lt","","",0,null],[11,"le","","",0,null],[11,"gt","","",0,null],[11,"ge","","",0,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"fmt","","",0,null],[11,"clone","","",0,null],[11,"from_vec","","from vector",3,{"inputs":[{"name":"vec"}],"output":{"name":"option"}}],[11,"new","","construct a new factory",3,{"inputs":[],"output":{"name":"bpf_factory"}}],[11,"with_capacity","","construct a factory with a specific capacity",3,{"inputs":[{"name":"usize"}],"output":{"name":"bpf_factory"}}],[11,"len","","Get current length",3,null],[11,"append","","Add an instruction",3,null],[11,"insert","","insert into specific location",3,null],[11,"to_kernel","","convert to kernel format for ingestion. This returns none if the program\nis &gt;= i32::MAX",3,null],[11,"cmp","","",2,null],[11,"partial_cmp","","",2,null],[11,"eq","","",2,null],[11,"fmt","","",2,null],[11,"clone","","",2,null],[11,"new","","Build a new LoadA instruction",4,{"inputs":[],"output":{"name":"loada"}}],[11,"packet_len","","A = PACKET_LEN",4,{"inputs":[],"output":{"name":"bpf_insn"}}],[11,"set","","A = K",4,{"inputs":[{"name":"u32"}],"output":{"name":"bpf_insn"}}],[11,"memory","","A = M\\[K\\]",4,{"inputs":[{"name":"u32"}],"output":{"name":"bpf_insn"}}],[11,"read_size","","Set read size",4,{"inputs":[{"name":"slicesize"}],"output":{"name":"loada"}}],[11,"packet","","A = P\\[K:#\\] develoepr MUST set read size.",4,null],[11,"packet_index","","A = P\\[X+K\\:#] developer MUST set read size",4,null],[11,"read_size","","Set read size",5,{"inputs":[{"name":"slicesize"}],"output":{"name":"loadx"}}],[11,"read","","X = M\\[K:#\\] MUST set read_size",5,null],[11,"set","","X = K",5,{"inputs":[{"name":"u32"}],"output":{"name":"bpf_insn"}}],[11,"packet_len","","X = LEN",5,{"inputs":[],"output":{"name":"bpf_insn"}}],[11,"ip_header_len","","X = IP Header Length (where the field starts at K)",5,{"inputs":[{"name":"u32"}],"output":{"name":"bpf_insn"}}],[11,"a","","Store A",6,{"inputs":[],"output":{"name":"storereg"}}],[11,"x","","Store X",6,{"inputs":[],"output":{"name":"storereg"}}],[11,"location","","M[K] = A|X",6,null],[11,"add","","Start an ADD Instruction",7,{"inputs":[],"output":{"name":"alu"}}],[11,"mul","","Start a MUL Instruction",7,{"inputs":[],"output":{"name":"alu"}}],[11,"sub","","Start a SUB Instruction",7,{"inputs":[],"output":{"name":"alu"}}],[11,"div","","Start a DIV Instruction",7,{"inputs":[],"output":{"name":"alu"}}],[11,"and","","Start an AND Instruction",7,{"inputs":[],"output":{"name":"alu"}}],[11,"or","","Start an OR Instruction",7,{"inputs":[],"output":{"name":"alu"}}],[11,"sl","","Start a LeftShift Instruction",7,{"inputs":[],"output":{"name":"alu"}}],[11,"sr","","Start a RightShift Instruction",7,{"inputs":[],"output":{"name":"alu"}}],[11,"not","","A = -A The Not Instruction",7,{"inputs":[],"output":{"name":"bpf_insn"}}],[11,"constant","","Do the operation against a constant",7,null],[11,"x_reg","","Do the operation against reg X (Index Register)",7,null],[11,"constant_jmp","","PC += K",8,{"inputs":[{"name":"u32"}],"output":{"name":"bpf_insn"}}],[11,"new","","Build a new jump",8,{"inputs":[{"name":"u8"},{"name":"u8"}],"output":{"name":"jmp"}}],[11,"eq","","Compare EQ",8,null],[11,"and","","Compare AND",8,null],[11,"gt","","Compare GT",8,null],[11,"gte","","Compare GTE",8,null],[11,"constant","","Against a constant",8,null],[11,"reg_x","","Against reg X (index register)",8,null],[11,"accept","","This will accept the packet. Really it is telling the kernel to accept\n~3.6GB length packet. So the kernel will just accept the whole packet.",9,{"inputs":[],"output":{"name":"bpf_insn"}}],[11,"reject","","This is reject the packet",9,{"inputs":[],"output":{"name":"bpf_insn"}}],[11,"read_constant","","Trim the packet to a constant length",9,{"inputs":[{"name":"u32"}],"output":{"name":"bpf_insn"}}],[11,"read_a","","Trim the packet to a length determined by A. Note that if A == 0 then the\npacket will be rejected",9,{"inputs":[],"output":{"name":"bpf_insn"}}],[11,"co_a_to_x","","X = A, A is not modified",10,{"inputs":[],"output":{"name":"bpf_insn"}}],[11,"copy_x_to_a","","A = X, X is not modified",10,{"inputs":[],"output":{"name":"bpf_insn"}}]],"paths":[[3,"bpf_insn"],[3,"bpf_program"],[4,"SliceSize"],[3,"bpf_factory"],[3,"LoadA"],[3,"LoadX"],[3,"StoreReg"],[3,"Alu"],[3,"Jmp"],[3,"Ret"],[3,"CopyReg"]]};
initSearch(searchIndex);
